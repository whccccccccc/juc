# 章节6 多线程锁

synchronized实现同步的基础:Java中的每一个对象都可以作为锁具体表现为以下3种形式。
- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的class对象。
- 对于同步方法块，锁是synchonized括号里配置的对象


## 公平锁和非公平锁
### 非公平锁
- 线程饿死
- 执行效率高
### 公平锁
- 效率低
- 各个线程都能分到公平的CPU时间片

## 可重入锁
- synchronized(隐式)和lock(显式)都是可重入锁
## 死锁
### 什么是死锁
> 两个或两个以上进程在执行过程中,因为争夺资源而造成一种互相等古代的现象,如果没有外力干涉,他们无法再执行下去

### 原因
- 系统资源不足
- 进程运行推进的顺序不合适
- 资源分配不当

### 验证死锁
- jps  类似于 ps-ef
- jstack jvm自带堆栈跟踪攻击